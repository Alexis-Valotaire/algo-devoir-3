\documentclass[devoir3.tex]{subfiles}

\begin{document}

\section*{Question 1}
Nous avons vu en classe un algorithme vorace pour résoudre le problème du retour de la monnaie en un nombre minimum de pièces. Nous avons observé que cet algorithme fonctionne correctement avec de pièces de monnaie canadiennes mais celui-ci ne trouve pas toujours la bonne réponse si, par exemple, des pièces de 12 cents sont ajoutées (e.g. il y a une erreur pour retourner 15 cents). Le problème général du retour de la monnaie peut être résolu exactement en utilisant la programmation dynamique. \\[0.2cm]
Soit n le nombre de pièces distinctes et soit \(T[1 \dots n]\) un tableau donnant la valeur de ces pièces (il n’y a aucun intérêt à trier ce tableau). Supposons une quantité illimitée de chaque type de pièces. Soit \(L\), une limite sur le montant à obtenir. \\

\textbf{a)} Pour \(1 \leq i \leq n\) et \(1 \leq j \leq L\), soit \(c_{i,j}\) le nombre minimum de pièces pour obtenir le montant \(j\) si on se limite aux pièces de type \(T[1], T[2], \dots , T[i]\). Si ce montant ne peut être obtenu alors \(c_{i,j} = +\infty \). Donnez une équation de récurrence pour \(c_{i,j}\) incluant les conditions initiales. \\

\textbf{b)} Donnez un algorithme de programmation dynamique pour calculer tous les \(c_{n,j}\) où \(1 \leq j \leq L\). Votre algorithme ne doit utiliser qu’un seul tableau (à une dimension) de longueur \(L\). \\

\begin{algorithm}[H]
      \KwData{\( T[1 \cdot\cdot\cdot  n], C[1 \cdot\cdot\cdot  L], entier \: n, entier \: L \)}
      \KwResult{réel med}
      	\If{ \(n = 1\)}{
      		\Return \(  \big( \frac{X[1] + Y[1]}{2} \big) \) \
      	}

      	\If{ \(n = 2\)}{
      		\Return \(  \big( \frac{ max(X[1], Y[1]) + min(X[2], Y[2])   }{2} \big) \) \
      	}

      	\(medX \gets Mediane(X[1 \cdot\cdot\cdot  n]) \) \;
      	\(medY \gets Mediane(Y[1 \cdot\cdot\cdot  n]) \) \;

      	\If{\(medX = medY\)}{
      		\Return medX
      	}

      	\eIf{\(medX < medY\)}
      	{
      		\eIf{\( n\bmod  2 = 0\)}
      		{
      			\Return TrouverMédiane(X[\( \frac{n}{2} +1\) ...  n], Y[1 ...  \( \frac{n}{2} -1\)], \( \frac{n}{2} +1\))
      		}
      		{
      			\Return TrouverMédiane(X[\( \frac{n}{2}\) ...  n], Y[1 ...  \( \frac{n}{2}\)], \( \frac{n}{2}\))
      		}
      	}
      	{
      		      		\eIf{\( n\bmod  2 = 0\)}
      		{
      			\Return TrouverMédiane(X[1 ...  \( \frac{n}{2} -1\)], Y[\( \frac{n}{2} +1\) ...  n], \( \frac{n}{2} +1\))
      		}
      		{
      			\Return TrouverMédiane(X[\( \frac{n}{2}\) ...  n], Y[1 ...  \( \frac{n}{2}\)], \( \frac{n}{2}\))
      		}
      	}


      \caption{Trouver \(c_{n,j}\)}
\end{algorithm}

\textbf{c)} Analysez le temps d’exécution de votre algorithme en fonction de \(n\)
et de \(L\).

\end{document}
